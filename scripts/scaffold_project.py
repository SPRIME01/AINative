#!/usr/bin/env python3
import pathlib

# Assuming the script is in project_edge_ai/scripts/
# PROJECT_ROOT will point to 'project_edge_ai'
PROJECT_ROOT = pathlib.Path(__file__).parent.parent.resolve()

# Define the full project structure.
# Using dict for directories, list for files within, or str for file content.
# '.gitkeep' files are added to empty directories intended to be versioned.
STRUCTURE = {
    "backend": {
        "src": {
            "ainative": {
                "app": {
                    "adapters": ["__init__.py", "adapters.py", ".gitkeep"],
                    "domain": ["__init__.py", "domain.py", ".gitkeep"],
                    "infrastructure": [
                        "__init__.py",
                        "main.py",
                        ".gitkeep",
                        {"routers": ["__init__.py", "example_router.py", ".gitkeep"]},
                    ],
                    "service": ["__init__.py", "service.py", ".gitkeep"],
                },
                "config": [
                    ".gitkeep"
                ],  # litellm.config.yaml is generated by another script
                "smolagents": ["agent_X_spec.yaml", "agent_Y_spec.yaml", ".gitkeep"],
                "prompts": {  # New prompts directory for agent-specific prompts
                    "__init__.py": "# Makes 'prompts' a Python package\n",
                    "strategist": [
                        "system_prompt.md",
                        "user_examples.md",
                        "README.md",
                        ".gitkeep",
                    ],
                    "research": [
                        "system_prompt.md",
                        "user_examples.md",
                        "README.md",
                        ".gitkeep",
                    ],
                    "builder": [
                        "system_prompt.md",
                        "user_examples.md",
                        "README.md",
                        ".gitkeep",
                    ],
                    "planner": [
                        "system_prompt.md",
                        "user_examples.md",
                        "README.md",
                        ".gitkeep",
                    ],
                    "librarian": [
                        "system_prompt.md",
                        "user_examples.md",
                        "README.md",
                        ".gitkeep",
                    ],
                    "scribe": [
                        "system_prompt.md",
                        "user_examples.md",
                        "README.md",
                        ".gitkeep",
                    ],
                    "critic": [
                        "system_prompt.md",
                        "user_examples.md",
                        "README.md",
                        ".gitkeep",
                    ],
                    "guardian": [
                        "system_prompt.md",
                        "user_examples.md",
                        "README.md",
                        ".gitkeep",
                    ],
                },
            }
        },
        "tests": {
            "__init__.py": "",
            "conftest.py": "",
            "adapters": ["__init__.py", ".gitkeep"],
            "domain": ["__init__.py", ".gitkeep"],
            "infrastructure": ["__init__.py", ".gitkeep"],
            "service": ["__init__.py", ".gitkeep"],
        },
        "Dockerfile": """# Auto-generated Dockerfile
FROM python:3.11-slim
WORKDIR /app

# Create a non-root user
RUN groupadd -r appuser && useradd -r -g appuser -s /sbin/nologin -c "Docker image user" appuser

# Copy requirements first to leverage Docker cache
COPY ./backend/requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy the rest of the backend application code
COPY ./backend /app/backend

# Ensure the entrypoint script is executable if you have one
# RUN chmod +x /app/backend/entrypoint.sh

USER appuser

# Add command to run the app, e.g.,
# CMD ["python", "backend/src/ainative/app/infrastructure/main.py"]
# Or if using an entrypoint script:
# ENTRYPOINT ["/app/backend/entrypoint.sh"]
""",
        "pyproject.toml": """[tool.poetry]
name = "ainative-backend"
version = "0.1.0"
description = "Backend for Edge AI Agent System"
authors = ["Your Name <you@example.com>"]
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.10"
fastapi = "^0.110.0"
uvicorn = {extras = ["standard"], version = "^0.27.0"}
litellm = "^1.30.6" # Example version, adjust as needed
python-dotenv = "^1.0.0"
# Add other core dependencies here

[tool.poetry.group.dev.dependencies]
pytest = "^8.0.0"
ruff = "^0.2.0"
mypy = "^1.8.0"
pre-commit = "^3.6.0"
# Add other dev dependencies

[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"

[tool.ruff]
line-length = 88
select = ["E", "W", "F", "I", "UP", "PL", "T20"]
ignore = ["E501"] # Handled by black

[tool.mypy]
strict = true
ignore_missing_imports = true
""",
        "requirements.txt": """# Auto-generated requirements.txt for Docker build if not using Poetry for deployment
# If using Poetry, this file can be generated via 'poetry export -f requirements.txt --output requirements.txt'
fastapi>=0.110.0
uvicorn[standard]>=0.27.0
litellm>=1.30.6
python-dotenv>=1.0.0
""",
    },
    "data": {
        "knowledge_graphs": [".gitkeep"],
        "models": [".gitkeep"],  # For local GGUF models, etc.
        "redis": [".gitkeep"],  # For Redis data persistence if used
    },
    "docs": {
        "APIReference.md": "# API Reference\n\nDetailed documentation for the project's API endpoints.",
        "GettingStarted.md": "# Getting Started\n\nStep-by-step guide to set up, configure, and run the project.",
        "architecture.md": "# System Architecture\n\nHigh-level overview of the system architecture, components, and interactions.",
        "prompts_guide.md": "# Prompts Guide\n\nBest practices and guidelines for writing effective prompts for the agents.",
        "agents": {
            "README.md": "# Agent Descriptions\n\nDetailed information about each agent's role, capabilities, and configuration.",
            "strategist_agent.md": "# Strategist Agent\n\n...",
            "research_agent.md": "# Research Agent\n\n...",
            "builder_agent.md": "# Builder Agent\n\n...",
            "planner_agent.md": "# Planner Agent\n\n...",
            "librarian_agent.md": "# Librarian Agent\n\n...",
            "scribe_agent.md": "# Scribe Agent\n\n...",
            "critic_agent.md": "# Critic Agent\n\n...",
            "guardian_agent.md": "# Guardian Agent\n\n...",
        },
        "concepts": {
            "model_context_protocol.md": "#  Agent Context Protocol (ACP)\n\nDetails about the ACP used for agent communication.",
            "runtime_optimization.md": "# Runtime Optimization\n\nTechniques and strategies for optimizing model performance on edge devices.",
        },
        "usage": {
            "daily_routine.md": "# Daily Routine\n\nIntegrating agents into daily workflows.",
            "weekly_routine.md": "# Weekly Routine\n\nIntegrating agents into weekly planning and review.",
        },
        "troubleshooting.md": "# Troubleshooting Guide\n\nCommon issues and their solutions.",
    },
    "frontend": {  # Basic structure, assuming it exists or can be created
        "public": [".gitkeep"],
        "src": [".gitkeep"],
        "index.html": "<!-- Frontend entry point -->",
        "package.json": '{ "name": "ainative-frontend", "version": "0.1.0" }',
    },
    "logs": [".gitkeep"],  # For runtime logs
    "scripts": [  # .gitkeep to ensure the directory is versioned even if all scripts are gitignored elsewhere
        ".gitkeep"
    ],
    ".gitignore": """# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# PEP 582; __pypackages__
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE settings
.idea/
.vscode/
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# macOS
.DS_Store
.AppleDouble
.LSOverride

# Windows
Thumbs.db
ehthumbs.db
Desktop.ini

# Logs and databases - handled by specific ignores below
# *.log
# *.sql
# *.sqlite

# Temporary files
*.swp
*~
*.tmp
*.bak
*.orig

# Project-specific ignores
# Ignore all contents of these directories by default
/project_edge_ai/logs/*
/project_edge_ai/data/redis/*
/project_edge_ai/data/models/*
/project_edge_ai/data/knowledge_graphs/*
# /project_edge_ai/backend/src/ainative/config/* # Be careful with config files

# But keep the .gitkeep files
!/project_edge_ai/logs/.gitkeep
!/project_edge_ai/data/redis/.gitkeep
!/project_edge_ai/data/models/.gitkeep
!/project_edge_ai/data/knowledge_graphs/.gitkeep
!/project_edge_ai/backend/src/ainative/config/.gitkeep
!/project_edge_ai/backend/src/ainative/config/litellm.config.yaml # Keep this one if generated
!/project_edge_ai/backend/src/ainative/config/otel-collector-config.yaml # Keep this one

# Sensitive files
credentials.json
*.pem
*.key
secrets.yaml
""",
    "README.md": """# Project Edge AI

Welcome to the Project Edge AI repository. This project aims to create a local group of AI agents running on an NVIDIA Jetson AGX Orin to assist with various tasks.

## Overview

(Provide a brief overview of the project, its goals, and the technology stack.)

## Getting Started

1.  **Prerequisites**: Ensure you have Docker, Python (Poetry recommended), and any other necessary hardware/software (NVIDIA JetPack, etc.).
2.  **Clone the repository**: `git clone <repository-url>`
3.  **Setup Backend**:
    ```bash
    cd project_edge_ai/backend
    poetry install
    # Activate virtual environment: poetry shell
    ```
4.  **Configuration**:
    *   Run `python ../scripts/generate_litellm_config.py` to create/update `backend/src/ainative/config/litellm.config.yaml`. Customize as needed.
    *   Set up any necessary environment variables (e.g., in a `.env` file).
5.  **Run the application**:
    ```bash
    # From project_edge_ai/backend directory
    poetry run uvicorn ainative.app.infrastructure.main:app --host 0.0.0.0 --port 8000 --reload
    ```

## Project Structure

(Briefly describe the main directories and their purpose, e.g., `backend`, `data`, `docs`, `scripts`.)

Refer to `docs/architecture.md` for a detailed system architecture and `docs/GettingStarted.md` for more setup information.
""",
    "pre-commit-config.yaml": """# See https://pre-commit.com for more information
# See https://pre-commit.com/hooks.html for more hooks
repos:
-   repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
    -   id: trailing-whitespace
    -   id: end-of-file-fixer
    -   id: check-yaml
    -   id: check-json
    -   id: check-toml
    -   id: check-added-large-files
    -   id: detect-private-key
-   repo: https://github.com/astral-sh/ruff-pre-commit
    rev: 'v0.2.2' # Or latest
    hooks:
    -   id: ruff
        args: [--fix, --exit-non-zero-on-fix]
    -   id: ruff-format
-   repo: https://github.com/pre-commit/mirrors-mypy
    rev: 'v1.8.0' # Or latest
    hooks:
    -   id: mypy
        additional_dependencies: ["types-PyYAML"] # Add types for libraries as needed
        exclude: ^(docs|tests)/ # Optional: exclude directories from mypy
""",
}


def safe_create_structure(
    base_path: pathlib.Path,
    structure_definition: dict[str, object],
    root_call: bool = True,
) -> None:
    """
    Creates directories and files. For files, it only creates them if they don't exist,
    or writes content if specified and the file is empty or doesn't exist.
    It avoids overwriting existing files with content unless the content is a placeholder
    or a configuration file explicitly marked for update.
    """
    if root_call:  # Ensure the absolute base path for the project exists
        base_path.mkdir(parents=True, exist_ok=True)

    for name, content in structure_definition.items():
        current_item_path = base_path / name
        if (
            name == ".gitkeep"
            and current_item_path.parent.exists()
            and any(current_item_path.parent.iterdir())
        ):
            # Don't create .gitkeep if directory is not empty (unless .gitkeep is the only thing)
            is_empty_except_gitkeep = True
            if current_item_path.parent.exists():
                items = list(current_item_path.parent.iterdir())
                if len(items) > 1 or (len(items) == 1 and items[0].name != ".gitkeep"):
                    is_empty_except_gitkeep = False
            if not is_empty_except_gitkeep:
                print(f"Skipped .gitkeep in non-empty dir: {current_item_path.parent}")
                continue

        if isinstance(content, dict):  # It's a directory
            current_item_path.mkdir(parents=True, exist_ok=True)
            # print(f"Ensured directory: {current_item_path}")
            safe_create_structure(
                current_item_path, content, root_call=False
            )  # Recurse

        elif isinstance(content, list):  # Directory with specific files/subdirs
            current_item_path.mkdir(parents=True, exist_ok=True)
            # print(f"Ensured directory: {current_item_path}")
            for item_in_list in content:
                if isinstance(item_in_list, str):  # File name
                    file_path = current_item_path / item_in_list
                    if not file_path.exists():
                        file_path.touch()
                        print(f"Created empty file: {file_path}")
                elif isinstance(item_in_list, dict):  # Nested structure
                    for sub_dir_name, sub_dir_content in item_in_list.items():
                        # Call recursively for the nested dict which represents a subdir
                        safe_create_structure(
                            current_item_path,
                            {sub_dir_name: sub_dir_content},
                            root_call=False,
                        )

        elif isinstance(
            content, str
        ):  # It's a file, content is the initial string for the file
            write_content = False
            current_content = ""
            if current_item_path.exists() and current_item_path.is_file():
                current_content = current_item_path.read_text(errors="ignore")

            if not current_item_path.exists():
                write_content = True
            # Check for specific config files that are okay to overwrite/update
            elif (
                name
                in [
                    "pyproject.toml",
                    ".gitignore",
                    "pre-commit-config.yaml",
                    "Dockerfile",
                    "README.md",
                    "requirements.txt",
                ]
                and content.strip()
            ):
                if (
                    not current_content.strip()
                    or "Auto-generated" in current_content
                    or "# Project Edge AI" in current_content
                    or "[tool.poetry]" in current_content
                ):  # if it's empty or looks like a template
                    write_content = True
                else:
                    print(
                        f"File exists with user content, skipped update: {current_item_path}"
                    )
            elif (
                not current_content.strip() and content.strip()
            ):  # File exists but is empty, and new content is not empty
                write_content = True

            if write_content:
                try:
                    current_item_path.parent.mkdir(parents=True, exist_ok=True)
                    current_item_path.write_text(content)
                    print(f"Created/Updated file: {current_item_path}")
                except Exception as e:
                    print(f"Error writing file {current_item_path}: {e}")
            elif current_item_path.exists() and not write_content:
                # print(f"File exists, skipped: {current_item_path}")
                pass
            # else:
            # print(f"File not written (no condition met): {current_item_path}")


if __name__ == "__main__":
    print(f"Project root for scaffolding: {PROJECT_ROOT}")
    if PROJECT_ROOT.name != "project_edge_ai":
        print("Warning: The script is expected to be in 'project_edge_ai/scripts/'.")
        print(
            f"Current project root is '{PROJECT_ROOT.name}'. Please ensure this is correct."
        )
        # Consider exiting if the path is not as expected, or make PROJECT_ROOT an argument.

    print("Starting scaffolding process...")
    safe_create_structure(PROJECT_ROOT, STRUCTURE)
    print("Scaffolding process complete.")
    print(f"Please review the changes under {PROJECT_ROOT}")
    print(
        "You may need to run 'poetry install' in 'project_edge_ai/backend/' if pyproject.toml was updated/created."
    )
    print(
        "Ensure 'otel-collector-config.yaml' and 'litellm.config.yaml' are correctly placed or generated in 'project_edge_ai/backend/src/ainative/config/'."
    )
